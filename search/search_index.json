{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MkAPI Documentation","text":"<p>MkAPI is a plugin for MkDocs, designed to facilitate the generation of API documentation for Python projects. MkAPI streamlines the documentation process by automatically extracting docstrings and organizing them into a structured format, making it easier for developers to maintain and share their API documentation.</p> <p>MkAPI supports two popular styles of docstrings: Google style and NumPy style, allowing developers to choose the format that best fits their project's needs.</p> <ul> <li>Google Style: Example Google Style Python Docstrings</li> <li>NumPy Style: Example NumPy Style Python Docstrings</li> </ul> <p>MkAPI is equipped with several key features that enhance the documentation experience:</p> <ul> <li>Type Annotation Support: Automatically incorporates type annotations from   function definitions into the documentation, reducing redundancy and   improving clarity.</li> <li>Object Type Inspection: Analyzes Python objects to determine their types,   enabling accurate representation in the documentation.</li> <li>Docstring Inheritance: Supports inheritance of docstring content from   parent classes, ensuring that subclasses retain relevant documentation without   duplication.</li> <li>Automatic Table of Contents Generation: Generates a table of contents for   each package, module, and class, improving navigation within the   documentation.</li> <li>Bidirectional Links: Creates links between the documentation and the source   code, allowing users to easily navigate between the two.</li> </ul> <p>MkAPI aims to simplify the documentation process, making it more efficient and accessible for developers, while ensuring that the generated documentation is comprehensive and easy to understand.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install the MkAPI plugin using pip:</p> <pre><code>pip install mkapi\n</code></pre> <p>MkAPI requires the following dependencies:</p> <ul> <li>Python 3.10 or higher</li> <li>MkDocs 1.6 or higher</li> </ul>"},{"location":"#configuration","title":"Configuration","text":"<p>To configure MkAPI, add the following lines to your <code>mkdocs.yml</code> file:</p> <pre><code>plugins:\n  - mkapi\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>MkAPI provides two modes to generate API documentation: Object mode and Page mode.</p>"},{"location":"#object-mode","title":"Object Mode","text":"<p>To generate the API documentation in a Markdown source, add three colons + object full name. The object can be a function, class, or module.</p> <pre><code>::: package.module.object\n</code></pre> <p>The Object mode is useful to embed an object's documentation in an arbitrary position of a Markdown source. For more details, see Object mode.</p>"},{"location":"#page-mode","title":"Page Mode","text":"<p>Using the Page mode, you can construct comprehensive API documentation for your project. You can enable this powerful feature with just one line in <code>mkdocs.yml</code>:</p> <pre><code>nav:\n  - index.md\n  - Reference:\n    - $api/package.***\n</code></pre> <p>For more details, see Page mode.</p>"},{"location":"usage/config/","title":"Configuration for MkAPI","text":"<p>Customize the behavior of the MkAPI plugin with the configuration settings outlined below.</p>"},{"location":"usage/config/#excluding-modules","title":"Excluding Modules","text":"<p>You can exclude the generation of documentation for specific modules using the plugin's <code>exclude</code> setting. This feature is particularly useful for omitting test modules, unnecessary components, or large modules that may clutter your documentation.</p> mkdocs.yml<pre><code>plugins:\n  - mkapi:\n      exclude:\n        - package.module_to_exclude\n</code></pre> <p>In the example above, the <code>package.module_to_exclude</code> module is excluded from the documentation generation.</p> <p>The <code>exclude</code> setting supports the use of shell-style wildcards for package/module names. For example, you can exclude all modules starting with <code>test_</code> by using the pattern <code>package.subpackage.test_*</code>.</p> <p>Note</p> <p>Module names starting with <code>_</code> are always excluded.</p>"},{"location":"usage/config/#search-exclusion","title":"Search Exclusion","text":"<p>You can exclude API documentation from search results using the <code>search_exclude</code> and <code>source_search_exclude</code> options.</p> mkdocs.yml<pre><code>plugins:\n  - mkapi:\n      search_exclude: false\n      source_search_exclude: true\n</code></pre> <ul> <li> <p><code>search_exclude</code>: This option allows you to exclude the entire API   documentation from search results.   When set to <code>true</code>, the generated API documentation   will be excluded from search results.   The default value is <code>false</code>.</p> </li> <li> <p><code>source_search_exclude</code>: This option is used to exclude source pages   from search results. If a page is a source page and this option is set to <code>true</code>,   it will be excluded from search results.   The default value is <code>true</code>.</p> </li> </ul> <p>These options help in customizing the search functionality to ensure that users can easily find the information they need without being overwhelmed by unnecessary results.</p>"},{"location":"usage/config/#save-option","title":"Save Option","text":"<p>You can save the generated markdown files of API pages using the <code>save</code> option. This feature is useful when you want to use the generated markdown files with external tools.</p> mkdocs.yml<pre><code>plugins:\n  - mkapi:\n      save: true  # Save to docs_dir\n</code></pre> <p>Or specify a custom directory:</p> mkdocs.yml<pre><code>plugins:\n  - mkapi:\n      save: \"output/markdown\"  # Save to custom directory\n</code></pre> <p>When this option is enabled:</p> <ul> <li>Markdown files for API pages (object pages and source pages) will be saved</li> <li>If <code>save</code> is <code>true</code>, files will be saved to <code>docs_dir</code></li> <li>If <code>save</code> is a string, files will be saved to the specified directory   (relative to the current directory)</li> <li>Files will be saved in the corresponding paths within the target directory</li> </ul> <p>Note</p> <p>The saved markdown files contain HTML elements (like <code>&lt;div&gt;</code> tags and Font Awesome icons) that are specific to MkDocs Material theme. When these files are used with other tools, you may need to modify the HTML elements to match your target documentation system's requirements.</p>"},{"location":"usage/config/#configuration-script","title":"Configuration script","text":"<p>You can further customize the plugin's behavior using the <code>config</code> setting in your configuration file. This allows you to define your own functions to enhance the documentation process.</p> mkdocs.yml<pre><code>plugins:\n  - mkapi:\n      config: config.py\n</code></pre> <p>Ensure that the <code>config.py</code> script file is located in the same directory as your <code>mkdocs.yml</code>, as shown below:</p> <pre><code>.\n\u251c\u2500 docs/\n\u2502  \u2514\u2500 index.md\n\u251c\u2500 config.py\n\u2514\u2500 mkdocs.yml\n</code></pre> <p>Note</p> <ul> <li>You can change the script name if needed.</li> <li>If the config file is a module and importable,   you can specify it as <code>config: modulename</code> without   the <code>.py</code> extension.</li> </ul> <p>Currently, five functions can be called from the MkAPI plugin. You can define your own functions to customize plugin behaviors or set navigation titles for sections, pages, and/or the table of contents.</p>"},{"location":"usage/config/#function-overview","title":"Function Overview","text":"<ul> <li>before_on_config: This function is called before the <code>on_config</code> event of the MkAPI plugin, allowing you to set up your environment.</li> <li>after_on_config: This function is executed after the <code>on_config</code> event, enabling you to make final adjustments.</li> <li>page_title: Returns a user-friendly title for a page, enhancing navigation.</li> <li>section_title: Generates a clear title for a section, improving organization.</li> <li>toc_title: Creates a concise title for the table of contents.</li> </ul> <p>By leveraging these functions, you can create a more tailored and user-friendly documentation experience with MkAPI.</p> <p>The following is an example of <code>config.py</code>.</p> config.py<pre><code>\"\"\"Config functions.\"\"\"\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from mkdocs.config.defaults import MkDocsConfig\n\n    from mkapi.plugins import MkApiPlugin\n\ndef before_on_config(config: MkDocsConfig, plugin: MkApiPlugin) -&gt; None:\n    \"\"\"Called before `on_config` event of MkAPI plugin.\"\"\"\n\ndef after_on_config(config: MkDocsConfig, plugin: MkApiPlugin) -&gt; None:\n    \"\"\"Called after `on_config` event of MkAPI plugin.\"\"\"\n\ndef page_title(name: str, depth: int) -&gt; str:\n    \"\"\"Return a page title.\"\"\"\n    return name\n\ndef section_title(name: str, depth: int) -&gt; str:\n    \"\"\"Return a section title.\"\"\"\n    return name\n\ndef toc_title(name: str, depth: int) -&gt; str:\n    \"\"\"Return a toc title.\"\"\"\n    return name.split(\".\")[-1]  # Remove prefix. Default behavior.\n</code></pre>"},{"location":"usage/config/#features-setting","title":"Features setting","text":"<p>MkAPI can be used with any MkDocs theme. However, we suggest considering the Material for MkDocs theme as one of the options due to its exceptional navigation features and user-friendly design.</p> <p>Below are some settings that can enhance your documentation experience if you choose to use this theme:</p> mkdocs.yml<pre><code>theme:\n  name: material (1)\n  features:\n    - content.tooltips (2)\n    - navigation.expand (3)\n    - navigation.indexes (4)\n    - navigation.sections (5)\n    - navigation.tabs (6)\n</code></pre> <ol> <li> <p>Material theme: Using the Material theme provides a sleek and modern interface for your documentation.</p> </li> <li> <p>Improved tooltips: With the <code>content.tooltips</code> feature, MkAPI displays object full names as tooltips, enhancing user experience by providing additional context without cluttering the interface. See Improved tooltips for more information.</p> </li> <li> <p>Navigation expansion: The <code>navigation.expand</code> feature automatically expands subpackages or submodules, making it easier for users to navigate through your documentation. Learn more about Navigation expansion.</p> </li> <li> <p>Section index pages: The <code>navigation.indexes</code> feature allows package sections to have their own summary or overview pages, providing a clearer structure. Check out Section index pages for details.</p> </li> <li> <p>Navigation sections: With the <code>navigation.sections</code> feature, packages are rendered as groups in the sidebar, improving organization and accessibility. More information can be found in Navigation sections.</p> </li> <li> <p>Navigation tabs: The <code>navigation.tabs</code> feature allows the API section to be placed in a menu layer, making it easily accessible. Discover more about Navigation tabs.</p> </li> </ol> <p>By considering these features, you can create a more intuitive and visually appealing documentation experience that encourages users to explore and utilize your library effectively.</p> <p>Instant loading</p> <p>Enabling the <code>navigation.instant</code> feature will cause links to source pages to function improperly, and the / buttons will be disabled.</p>"},{"location":"usage/object/","title":"Object Mode","text":"<p>MkAPI offers an Object mode that allows you to seamlessly embed object documentation within your Markdown source.</p>"},{"location":"usage/object/#demonstration-package","title":"Demonstration Package","text":"<p>In this section, we utilize a demonstration package called <code>example</code> to illustrate the Object mode of MkAPI. This package includes a module named <code>mod_a</code> and a subpackage named <code>sub</code>, which contains a module named <code>mod_b</code>.</p> <p>The directory structure of the <code>example</code> package is as follows:</p> <pre><code>example/\n\u251c\u2500 __init__.py\n\u251c\u2500 mod_a.py\n\u2514\u2500 sub/\n   \u251c\u2500 __init__.py\n   \u2514\u2500 mod_b.py\n</code></pre>"},{"location":"usage/object/#top-level-package","title":"Top-level Package","text":"<p>Let\u2019s first explore the top-level package <code>example</code>. To embed the object documentation in your Markdown source, you can use the following syntax:</p> <pre><code>::: example\n</code></pre> <p>The line must start with three colons (<code>:::</code>), followed by a space (<code>\u2423</code>) and the full name of the object (e.g., <code>package.module.function</code>). In this case, we simply use the package name <code>example</code>. MkAPI scans the Markdown source to find this syntax pattern and converts it into the corresponding object documentation as shown below:</p> <p> source package example </p> <p>Example package.</p> <p> Modules </p> <ul> <li> <p>example.sub \u2014 Subpackage.</p> </li> <li> <p>example.mod_a \u2014 Module A.</p> </li> </ul> <p>Note</p> <p>In the example above, the green dashed border serves as a visual guide to clarify the region of the documentation generated by MkAPI.</p> <p>In the above example, the object type (package) and its name (<code>example</code>) are displayed. This section serves as the heading of the object documentation.</p> <p>At the right end of the heading, a [source] button is provided. Clicking this button will navigate to the source code of the object. Next to the [source] button, a  button is provided. Clicking this button will hide the documentation to save space, and the button will change to a  button. When you click the  button again, the documentation will be shown once more.</p> <p>Following the heading, the main content of the documentation is rendered. The content of the <code>example</code> package is simply a one-line summary:</p> example/__init__.py<pre><code>\"\"\"Example package.\"\"\"\n</code></pre> <p>The <code>example</code> package contains a <code>example.sub</code> subpackage and a <code>example.mod_a</code> module. A Modules section is automatically generated and the <code>example.sub</code> subpackage and <code>example.mod_a</code> module are listed in this section.</p> <p>Note</p> <p>This is because the <code>example</code> package does not define or import any members. If there are members, they will take precedence.</p> <p>Like the heading, the Modules section also contains a / button. The behavior of this button is the same as that of the heading. All sections of the object documentation are collapsible, as shown in the following example.</p>"},{"location":"usage/object/#package-with-members","title":"Package with Members","text":"<p>If a package has members, MkAPI automatically lists them as a table of contents (TOC), categorizing them by type (class, function, or module).</p> <p>In our example, the <code>example.sub</code> package has some members. Check the output:</p> <pre><code>::: example.sub\n</code></pre> <p> source package example.sub </p> <p>Subpackage.</p> <p> Classes </p> <ul> <li> <p>ClassA \u2014 Class A.</p> </li> <li> <p>ClassB \u2014 Class B.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>func_a \u2014 Function A.</p> </li> <li> <p>func_b \u2014 Function B.</p> </li> </ul> <p>In the above example, the documentation for the <code>example.sub</code> package includes:</p> <ul> <li>A Classes section   including two classes: <code>ClassA</code> and <code>ClassB</code>.</li> <li>A Functions section   including two functions: <code>func_a</code> and <code>func_b</code>.</li> </ul> <p>These names link to the object documentation for easy navigation if the objects are defined in the current MkDocs project. A summary line for each class and function is also provided for convenience.</p> <p>Below is the source code of <code>example/sub/__init__.py</code>.</p> example/sub/__init__.py<pre><code>\"\"\"Subpackage.\"\"\"\n\nfrom ..mod_a import ClassA, func_a\nfrom .mod_b import ClassB, func_b\n\n__all__ = [\"ClassA\", \"ClassB\", \"func_a\", \"func_b\"]\n</code></pre> <p>The <code>example.sub</code> package also has an<code>__all__</code> attribute. The package members listed in the TOC are sorted by the order of appearance in the <code>__all__</code> attribute.</p>"},{"location":"usage/object/#module","title":"Module","text":"<p>A Python module consists of classes and functions as its members. MkAPI automatically adds a list of members.</p> <pre><code>::: example.mod_a\n</code></pre> <p> source module example.mod_a </p> <p>Module A.</p> <p> Classes </p> <ul> <li> <p>ClassA \u2014 Class A.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>func_a \u2014 Function A.</p> </li> <li> <p>sum_and_product \u2014 Computes the sum and product of two integers</p> </li> </ul>"},{"location":"usage/object/#function","title":"Function","text":"<p>The <code>example.mod_a</code> module contains a function named <code>func_a</code>. You can embed it like this:</p> <pre><code>::: example.mod_a.func_a\n</code></pre> <p> source func_a(x: int) \u2192 int </p> <p>Function A.</p> <p> Parameters </p> <ul> <li> <p>x :  int \u2014 An integer.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>int \u2014 An integer.</p> </li> </ul> <p>See Also</p> <ul> <li><code>ClassA.method_a</code></li> <li><code>ClassB.method_b</code></li> <li><code>func_b</code></li> </ul> <p>The heading of the object documentation contains a tooltip displaying the full name of the object. You can view the full name by hovering your mouse cursor over the function name <code>func_a</code> in the example above. This feature is helpful for quickly identifying the object, keeping the documentation concise.</p> <p>You can find a See also section at the bottom of the documentation. This section contains links to the documentation of listed objects. Again, hovering your mouse cursor over the links will display a tooltip with the full name of each object. Instructions on how to generate these links will be described below.</p>"},{"location":"usage/object/#class","title":"Class","text":"<p>The <code>example.mod_a</code> module contains a class named <code>ClassA</code>. You can embed it in the same way as functions.</p> <pre><code>::: example.mod_a.ClassA\n</code></pre> <p> source class ClassA(a: str) </p> <p>Class A.</p> <p> Parameters </p> <ul> <li> <p>a :  str \u2014 A string.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>attr_a :  str \u2014 Attribute A.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>method_a \u2014 Method A. Return <code>ClassA</code>.</p> </li> </ul> <p>A class has its own members like modules. You can find Attributes and Methods sections as the TOC. When a class has many members, you can hide and show the members by clicking the / button in these sections of the class documentation.</p>"},{"location":"usage/object/#method","title":"Method","text":"<p>Methods can also be embedded in a Markdown source by its qualified name.</p> <pre><code>::: example.mod_a.ClassA.method_a\n</code></pre> <p> source method ClassA.method_a(x: Iterable[str], y: ClassB) \u2192 ClassA </p> <p>Method A. Return <code>ClassA</code>.</p> <p> Parameters </p> <ul> <li> <p>x :  Iterable[str] \u2014 An iterable of strings.</p> </li> <li> <p>y :  ClassB \u2014 An instance of <code>ClassB</code>.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>ClassA \u2014 An instance of <code>ClassA</code>.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p>The heading of a method's documentation contains a tooltip displaying the full name of the method along with the class to which the method belongs. You can also click the  button to display the qualified names of all methods on the current page.</p>"},{"location":"usage/object/#source-code","title":"Source Code","text":"<p>Finally, check the source code of <code>example/mod_a.py</code>.</p> example/mod_a.py<pre><code>\"\"\"Module A.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from collections.abc import Iterable\n\n    from .sub.mod_b import ClassB\n\n\nclass ClassA:\n\n    attr_a: str = \"string\"\n    \"\"\"Attribute A.\"\"\"\n\n    def __init__(self, a: str):\n        \"\"\"Class A.\n\n        Args:\n            a: A string.\n        \"\"\"\n        self.attr_a = a\n\n    def method_a(self, x: Iterable[str], y: ClassB) -&gt; ClassA:\n        \"\"\"Method A. Return `ClassA`.\n\n        Args:\n            x: An iterable of strings.\n            y: An instance of `ClassB`.\n\n        Returns:\n            An instance of `ClassA`.\n        \"\"\"\n        if not x:\n            raise ValueError\n\n        return self\n\n\ndef func_a(x: int) -&gt; int:\n    \"\"\"Function A.\n\n    Args:\n        x: An integer.\n\n    Returns:\n        An integer.\n\n    See Also:\n        - `ClassA.method_a`\n        - `ClassB.method_b`\n        - [`func_b`][example.sub.mod_b.func_b]\n    \"\"\"\n    return 2 * x\n\n\ndef sum_and_product(x, y):\n    \"\"\"Computes the sum and product of two integers\n\n    Parameters\n    ----------\n    x : int\n\n    y : int\n\n\n    Returns\n    -------\n    s : int\n      sum of x and y\n    p : int\n      product of x and y\n    \"\"\"\n    return x+y, x*y\n</code></pre> <p>In the <code>See Also:</code> section of the <code>func_a</code> function, <code>ClassA.method_a</code> is listed as just <code>`ClassA.method_a`</code>. This is because <code>ClassA</code> is defined in the same module as <code>func_a</code> and it is visible from <code>func_a</code>. MkAPI recognizes the fully qualified name and embeds a link to the corresponding object documentation.</p> <p><code>ClassB.method_b</code> is also listed as just <code>`ClassB.method_b`</code>. Although <code>ClassB</code> isn't defined in the same module, it is visible from <code>func_a</code> because <code>ClassB</code> is imported.</p> <p>Note</p> <p><code>ClassB</code> is imported in a <code>TYPE_CHECKING</code> context so that it is not visible to the Python interpreter. MkAPI inspects the source code using abstract syntax tree (AST) to find objects.</p> <p>For <code>func_b</code> in <code>example.sub.mod_b</code>, Markdown link syntax is used because <code>func_b</code> is not visible from <code>func_a</code>. If you write it as just <code>`func_b`</code>, MkAPI will not be able to identify the object, and the link will not be generated.</p> <p>Note</p> <p>Did you notice that the link to the <code>func_a</code> function is written on this page (not in the docstring)? It is written as follows:</p> <pre><code>In the `See Also:` section of the [`func_a`][example.mod_a.func_a]\nfunction, `ClassA.method_a` is ...\n</code></pre> <p>Now, you might be wondering if you have to write all of the module members by yourself. The Page mode of MkAPI will assist you.</p>"},{"location":"usage/page/","title":"Page Mode","text":"<p>Unlock the full potential of your Python project with MkAPI's Page mode, designed to create comprehensive and user-friendly API documentation.</p>"},{"location":"usage/page/#simple-navigation-setup","title":"Simple Navigation Setup","text":"<p>Getting started with Page mode is a breeze! Just add a single line to the <code>nav</code> section of your <code>mkdocs.yml</code> file:</p> mkdocs.yml<pre><code>nav:\n  - index.md  # A normal page.\n  - $api/package.module  # API pages with the special syntax.\n</code></pre> <p>The leading <code>$</code> acts as a marker, indicating that this entry should be processed by MkAPI to generate dynamic API documentation. The text between the <code>$</code> and the last <code>/</code> specifies the name of the API directory and serves as the URI prefix. In this case, MkAPI creates two directories <code>api</code> and <code>src</code> in a <code>docs</code> directory. <code>api</code> is for documentation and <code>src</code> is for source code.</p> <pre><code>.\n\u251c\u2500 docs/\n\u2502  \u251c\u2500 api/\n\u2502  \u2502  \u2514\u2500 package\n\u2502  \u2502     \u2514\u2500 module.md\n\u2502  \u251c\u2500 src/\n\u2502  \u2502  \u2514\u2500 package\n\u2502  \u2502     \u2514\u2500 module.md\n\u2502  \u2514\u2500 index.md\n\u2514\u2500 mkdocs.yml\n</code></pre> <p>You can change the directory name for source code by splitting the prefix with a colon:</p> mkdocs.yml<pre><code>nav:\n  - index.md\n  - $api:src/package.module\n</code></pre> <p>Note</p> <ul> <li>The <code>src</code> directory is the default source code directory.</li> <li>You can change the names <code>api</code> and <code>src</code> as long as it is a valid   directory name.</li> <li>Since MkAPI version 3.0, files generated by MkAPI are stored in memory   and not written to disk.</li> </ul> <p>In the example above, only one <code>api/package/module.md</code> file for documentation and one <code>src/package/module.md</code> file for source code will be created.</p>"},{"location":"usage/page/#collecting-modules","title":"Collecting Modules","text":"<p>To gather a collection of subpackages or submodules, you can use the <code>*</code> symbol. Consider the following directory structure:</p> <pre><code>package/\n\u251c\u2500 subpackage1/\n\u2502  \u251c\u2500 __init__.py\n\u2502  \u251c\u2500 module_11.py\n\u2502  \u2514\u2500 module_12.py\n\u251c\u2500 subpackage2/\n\u2502  \u251c\u2500 __init__.py\n\u2502  \u251c\u2500 module_21.py\n\u2502  \u2514\u2500 module_22.py\n\u251c\u2500 __init__.py\n\u251c\u2500 module1.py\n\u2514\u2500 module2.py\n</code></pre> <p>There are three effective ways to collect module under the <code>package</code> directory.</p>"},{"location":"usage/page/#package","title":"package.*","text":"<ul> <li>Collects all modules under the <code>package</code> directory.</li> <li>The <code>nav</code> section is extended vertically.</li> </ul> <p>Example:</p> <pre><code>nav:\n  - index.md\n  - $api/package.*\n  - other.md\n</code></pre> <p>This will be transformed into:</p> <pre><code>nav:\n  - index.md\n  - package: api/package/README.md\n  - module_1: api/package/module_1.md\n  - module_2: api/package/module_2.md\n  - other.md\n</code></pre>"},{"location":"usage/page/#package_1","title":"package.**","text":"<ul> <li>Collects modules under the <code>package</code> directory and   its subdirectories recursively.</li> <li>The <code>nav</code> section is extended vertically in a flat structure.</li> <li>Optionally, you can set a section title, such as <code>API</code>.</li> </ul> <p>Example:</p> <pre><code>nav:\n  - index.md\n  - API: $api/package.**\n  - other.md\n</code></pre> <p>This will be transformed into:</p> <pre><code>nav:\n  - index.md\n  - API:\n    - package: api/package/README.md\n    - subpackage_1: api/package/subpackage_1/README.md\n    - module_11: api/package/subpackage_1/module_11.md\n    - module_21: api/package/subpackage_1/module_12.md\n    - subpackage_2: api/package/subpackage_2/README.md\n    - module_21: api/package/subpackage_2/module_21.md\n    - module_22: api/package/subpackage_2/module_22.md\n    - module_1: api/package/module_1.md\n    - module_2: api/package/module_2.md\n  - other.md\n</code></pre>"},{"location":"usage/page/#package_2","title":"package.***","text":"<ul> <li>Collects modules under the <code>package</code> directory and   its subdirectories recursively.</li> <li>The <code>nav</code> section is extended to maintain the same   tree structure as the package.</li> <li>Optionally, you can set a top section title, such as <code>API</code>.</li> </ul> <p>Example:</p> <pre><code>nav:\n  - index.md\n  - API: $api/package.***\n  - other.md\n</code></pre> <p>This will be transformed into:</p> <pre><code>nav:\n  - index.md\n  - API:\n    - package: api/package/README.md\n      - subpackage_1:\n        - subpackage_1: api/package/subpackage_1/README.md\n        - module_11: api/package/subpackage_1/module_11.md\n        - module_12: api/package/subpackage_1/module_12.md\n      - subpackage_2:\n        - subpackage_2: api/package/subpackage_2/README.md\n        - module_21: api/package/subpackage_2/module_21.md\n        - module_22: api/package/subpackage_2/module_22.md\n    - module_1: api/package/module_1.md\n    - module_2: api/package/module_2.md\n  - other.md\n</code></pre> <p>Note</p> <ul> <li><code>README.md</code> serves as an index page for packages,   corresponding to <code>__init__.py</code>.</li> </ul>"},{"location":"usage/writing/","title":"Writing Docstrings with MkAPI","text":"<p>Writing clear and informative docstrings is essential for effective documentation. This guide explains how to write docstrings using MkAPI's features.</p>"},{"location":"usage/writing/#what-is-a-docstring","title":"What is a Docstring?","text":"<p>A docstring is a special type of comment in Python that describes what a module, class, method, or function does. It is written as the first statement in the code block and is enclosed in triple quotes (<code>\"\"\"</code> or <code>'''</code>). Docstrings are accessible through the built-in <code>help()</code> function and are used by documentation generators like MkAPI.</p>"},{"location":"usage/writing/#basic-structure-of-a-docstring","title":"Basic Structure of a Docstring","text":"<p>When writing a docstring, consider the following structure:</p> <ol> <li>Summary Line: A brief description of the function or class.</li> <li>Parameters: A section that describes the input parameters, their types,    and what they represent.</li> <li>Returns: A section that describes the return value and its type.</li> <li>Raises: A section that lists any exceptions that the function may raise.</li> <li>Examples: Optional, but providing examples of how to use the function    can be very helpful.</li> </ol> <p>Now that we understand the basic structure, let's explore the unique features of MkAPI.</p>"},{"location":"usage/writing/#unique-features-of-mkapi","title":"Unique Features of MkAPI","text":"<p>One of the unique features of MkAPI is that it does not introduce its own syntax within docstrings. For example, to reference objects, you do not need to use Markdown link syntax like <code>[`object`][package.module.object]</code>. Simply writing the inline code is sufficient like <code>`object`</code>.</p> <p>Note</p> <p>In addition to using inline code references in docstrings, you can also utilize the standard link syntax <code>[text][package.module.object]</code> to create links within MkDocs markdown documents that point to the corresponding objects in the API documentation.</p>"},{"location":"usage/writing/#why-not-use-markdown-link-syntax","title":"Why Not Use Markdown Link Syntax?","text":""},{"location":"usage/writing/#from-a-users-perspective","title":"From a user's perspective","text":"<p>Avoiding Markdown link syntax in docstrings makes the documentation easier to read and understand. Users often read docstrings directly in the source code or as popups in IDEs like Visual Studio Code. Introducing unnecessary syntax can make the text cluttered and distracting. MkAPI addresses this by generating clean and readable documentation without special syntax, ensuring that users can quickly grasp the information they need.</p>"},{"location":"usage/writing/#from-a-developers-perspective","title":"From a developer's perspective","text":"<p>Using Markdown link syntax can be problematic, especially after refactoring the code. Every time the code is refactored, all the docstrings need to be updated to reflect the changes in the links. MkAPI's approach of automatically generating links from inline code eliminates this issue. It recognizes the context in which the docstring is written and resolves the names accurately, reducing the maintenance burden on developers and ensuring that the documentation remains up-to-date and relevant.</p>"},{"location":"usage/writing/#how-automatic-link-generation-works","title":"How Automatic Link Generation Works","text":"<p>MkAPI can automatically generate links from inline code. It recognizes the context in which the docstring is written.</p> <p>In a module's docstring, MkAPI resolves the names by referencing the namespace within the module's scope. In functions and classes, MkAPI resolves the names of children, parent, and sibling objects.</p> <p>This feature allows for more accurate and context-aware documentation generation. When a docstring references an object, MkAPI will look up the hierarchy to find the correct child, parent, or sibling, ensuring that the generated links are accurate and relevant.</p> <p>For example, if you have a class with several methods, and one method's docstring references another method in the same class, MkAPI will correctly resolve the reference to the sibling method. Similarly, if a method references an attribute or another method in a parent class, MkAPI will resolve the reference to the parent object.</p> <p>This automatic resolution of parent and sibling names enhances the usability and accuracy of the generated documentation, making it easier for users to navigate and understand the relationships between different parts of your code.</p>"},{"location":"usage/writing/#automatic-link-generation-for-types","title":"Automatic Link Generation for Types","text":"<p>MkAPI automatically generates links for type hints in class and function definitions, and types written in the docstring sections.</p> <p>Even when the types are outside the library and cannot be linked, a tooltip with the full name is displayed. This allows users to verify the actual type by hovering over it.</p>"},{"location":"usage/writing/#importance-of-the-summary-line","title":"Importance of the Summary Line","text":"<p>The summary line is used in the table of contents (TOC) for modules and classes to display a list of members. It is crucial for navigating users through the documentation. MkAPI automatically generates the TOC, making it easier for users to find and understand the structure of your code.</p>"},{"location":"usage/writing/#hot-reload","title":"Hot Reload","text":"<p>By using the <code>mkdocs serve</code> command, you can view your API documentation in real-time while editing your source code and docstrings. This feature allows you to see the changes immediately, ensuring that your documentation is always up-to-date with your latest code modifications.</p> <p>Additionally, by using the <code>--dirty</code> mode, only the modified modules are reloaded. This means that even if your library grows large, you won't have to wait for the entire documentation to refresh. This efficient reloading process saves time and enhances your productivity.</p>"},{"location":"usage/writing/#summary","title":"Summary","text":"<p>This guide has provided an overview of how to write effective docstrings using MkAPI's features. By following the structure and guidelines provided, you can create clear and informative documentation.</p>"},{"location":"api/mkapi/","title":"mkapi","text":"mkapi<p> source package mkapi </p> <p>MkAPI is a plugin for MkDocs, designed to generate API documentation.</p> <p> Modules </p> <ul> <li> <p>mkapi.config \u2014 Configuration for MkAPI.</p> </li> <li> <p>mkapi.nav \u2014 Navigation module for API documentation.</p> </li> <li> <p>mkapi.page \u2014 Page class.</p> </li> <li> <p>mkapi.parser \u2014 Parsing and managing Python objects for documentation generation.</p> </li> <li> <p>mkapi.plugin</p> </li> <li> <p>mkapi.renderer \u2014 Render documentation for Python objects.</p> </li> </ul>"},{"location":"api/mkapi/config/","title":"mkapi.config","text":"mkapi.config<p> source module mkapi.config </p> <p>Configuration for MkAPI.</p> <p> Classes </p> <ul> <li> <p>Config \u2014 Configuration for MkAPI.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>set_config \u2014 Set the config object.</p> </li> <li> <p>get_config \u2014 Get the config object.</p> </li> <li> <p>get_function \u2014 Get a function by name from the config file.</p> </li> </ul> <p> source class Config(config_file_path: str | bytes | None = None) </p> <p>Bases : BaseConfig</p> <p>Configuration for MkAPI.</p> <p> source set_config(config: Config) \u2192 None </p> <p>Set the config object.</p> <p> source get_config() \u2192 Config </p> <p>Get the config object.</p> <p> source get_function(name: str) \u2192 Callable | None </p> <p>Get a function by name from the config file.</p>"},{"location":"api/mkapi/nav/","title":"mkapi.nav","text":"mkapi.nav<p> source module mkapi.nav </p> <p>Navigation module for API documentation.</p> <p>Provide utility functions for managing and updating the navigation structure of API documentation. Include functions to retrieve module names, build navigation trees, and update navigation entries dynamically.</p> <p> Functions </p> <ul> <li> <p>get_apinav \u2014 Retrieve a list of module names based on the specified module name and depth.</p> </li> <li> <p>gen_apinav \u2014 Yield tuples of (module name, is_section, depth).</p> </li> <li> <p>update_apinav \u2014 Update the API navigation structure.</p> </li> <li> <p>build_apinav \u2014 Build the API navigation structure.</p> </li> <li> <p>split_name_depth \u2014 Split a nav entry into name and depth.</p> </li> <li> <p>update_nav \u2014 Update the navigation structure.</p> </li> </ul> <p> source get_apinav(name: str, depth: int, predicate: Callable[[str], bool] | None = None) \u2192 list </p> <p>Retrieve a list of module names based on the specified module name and depth.</p> <p>Check if the given module name corresponds to a valid module path. If the module is not a package, return a list containing only the module name. If the module is a package, retrieve submodule names based on the specified depth.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the module for which to retrieve the navigation.</p> </li> <li> <p>depth :  int \u2014 The depth level for retrieving submodules:</p> <ul> <li>1: Return the module name and its immediate submodules.</li> <li>2: Return a flat list of the module and its submodules,      including deeper levels.</li> <li>3: Return a nested dictionary structure representing the module      and its submodules.</li> </ul> </li> <li> <p>predicate :  Callable[[str], bool], optional \u2014 An optional predicate function to filter submodule names. If provided, only submodules that satisfy this predicate will be included in the result.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list \u2014 A list of module names or a nested structure of module names based on the specified depth. Return an empty list if the module path is invalid.</p> </li> </ul> <p> source gen_apinav(nav: list, depth: int = 0) \u2192 Generator[tuple[str, bool, int], Any, None] </p> <p>Yield tuples of (module name, is_section, depth).</p> <p>Iterate over the provided navigation list and yield tuples containing the name of each module or section, a boolean indicating whether the item is a section, and the depth of the item in the navigation hierarchy. Allow for dynamic modification of section names or navigation items based on the values sent back during iteration.</p> <p> Parameters </p> <ul> <li> <p>nav :  list \u2014 A list representing the navigation structure, which can contain module names or nested dictionaries representing sections and their corresponding pages.</p> </li> <li> <p>depth :  int, optional \u2014 The current depth in the navigation hierarchy. Defaults to 0.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>tuple[str, bool, int] \u2014 A tuple containing:</p> <ul> <li>module name (str): The name of the module or section.</li> <li>is_section (bool): True if the item is a section, False otherwise.</li> <li>depth (int): The depth of the item in the navigation hierarchy.</li> </ul> </li> </ul> <p> Examples </p> <pre><code>nav_structure = ['module1', {'section1': ['module2', 'module3']}]\nfor name, is_section, depth in gen_apinav(nav_structure):\n    print(name, is_section, depth)\n</code></pre> <pre><code>module1 False 0\nsection1 True 0\nmodule2 False 1\nmodule3 False 1\n</code></pre> <pre><code>nav_structure = ['moduleA', {'sectionA': ['moduleB']}]\nfor name, is_section, depth in gen_apinav(nav_structure, 1):\n    print(name, is_section, depth)\n</code></pre> <pre><code>moduleA False 1\nsectionA True 1\nmoduleB False 2\n</code></pre> <p> source update_apinav(nav: list, page: Callable[[str, int], str | dict[str, str]], section: Callable[[str, int], str] | None = None) \u2192 None </p> <p>Update the API navigation structure.</p> <p>Iterate over the provided navigation list and update it by generating page and section titles based on the provided callable functions. Utilize a generator to traverse the navigation structure, allowing for dynamic modification of section names and page titles.</p> <p> Parameters </p> <ul> <li> <p>nav :  list \u2014 A list representing the navigation structure, which can contain module names, sections, and nested pages.</p> </li> <li> <p>page :  Callable[[str, int], str | dict[str, str]] \u2014 A callable function that takes a module name and its depth as arguments and returns a string or a dictionary representing the page title or content.</p> </li> <li> <p>section :  Callable[[str, int], str] | None, optional \u2014 A callable function that takes a section name and its depth as arguments and returns a string representing the section title. If None, the section name will remain unchanged. Defaults to None.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>StopIteration \u2014 If the generator completes without yielding any further values.</p> </li> </ul> <p> Examples </p> <pre><code>def page_title(name: str, depth: int) -&gt; str:\n    return f\"{name.upper()}.{depth}\"\ndef section_title(name: str, depth: int) -&gt; str:\n    return f\"Section: {name}\"\nnav_structure = [\"module1\", {\"section1\": [\"module2\"]}]\nupdate_apinav(nav_structure, page_title, section_title)\nprint(nav_structure)\n</code></pre> <pre><code>['MODULE1.0', {'Section: section1': ['MODULE2.1']}]\n</code></pre> <p> source build_apinav(nav: list, create_apinav: Callable[[str, str], list]) \u2192 list </p> <p>Build the API navigation structure.</p> <p>Construct a navigation structure for the API documentation by iterating over the provided navigation list. Process each item, checking for API entries and creating corresponding navigation entries using the provided <code>create_apinav</code> function. The resulting navigation structure can include both flat and nested entries based on the input.</p> <p> Parameters </p> <ul> <li> <p>nav :  list \u2014 A list representing the initial navigation structure, which can contain module names, sections, and nested pages.</p> </li> <li> <p>create_apinav :  Callable[[str, str], list] \u2014 A callable function that takes a module name and <code>src_uri</code> as arguments and returns a list of navigation entries for that module.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list \u2014 A list representing the updated navigation structure, which includes the processed API entries and any nested structures.</p> </li> </ul> <p> Examples </p> <pre><code>def create_apinav(name: str, path: str) -&gt; list:\n    return [f\"{name}.md\"]\nnav_structure = [\"$api/module1\", {\"section1\": [\"$api/module2\"]}]\nupdated_nav = build_apinav(nav_structure, create_apinav)\nprint(updated_nav)\n</code></pre> <pre><code>['module1.md', {'section1': ['module2.md']}]\n</code></pre> <p> source split_name_depth(name: str) \u2192 tuple[str, int] </p> <p>Split a nav entry into name and depth.</p> <p> source update_nav(nav: list, create_page: Callable[[str, str], str], section_title: Callable[[str, int], str] | None = None, page_title: Callable[[str, int], str] | None = None, predicate: Callable[[str], bool] | None = None) \u2192 None </p> <p>Update the navigation structure.</p> <p>Update the provided navigation list by constructing API entries and section titles based on the specified callable functions. Process each entry in the navigation list, creating pages and sections as needed, and modify the navigation structure in place.</p> <p> Parameters </p> <ul> <li> <p>nav :  list \u2014 A list representing the navigation structure, which can contain module names, sections, and nested pages.</p> </li> <li> <p>create_page :  Callable[[str, str, list[str]], str] \u2014 A callable function that takes a module name, path, and filters as arguments and returns a string representing the URI of the created page.</p> </li> <li> <p>section_title :  Callable[[str, int], str] | None, optional \u2014 A callable function that takes a section name and its depth as arguments and returns a string representing the section title. If None, the section title will remain unchanged. Defaults to None.</p> </li> <li> <p>page_title :  Callable[[str, int], str] | None, optional \u2014 A callable function that takes a page name and its depth as arguments and returns a string representing the page title. If None, the page title will remain unchanged. Defaults to None.</p> </li> <li> <p>predicate :  Callable[[str], bool] | None, optional \u2014 An optional predicate function to filter the navigation entries. If provided, only entries that satisfy this predicate will be included in the updated navigation structure.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>None \u2014 This function modifies the <code>nav</code> list in place and does not     return a value.</p> </li> </ul>"},{"location":"api/mkapi/page/","title":"mkapi.page","text":"mkapi.page<p> source module mkapi.page </p> <p>Page class.</p> <p> Classes </p> <ul> <li> <p>PageKind \u2014 Enum representing different types of pages.</p> </li> <li> <p>Page \u2014 Page class.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>generate_module_markdown \u2014 Create module page.</p> </li> <li> <p>generate_object_markdown \u2014 Create object page.</p> </li> <li> <p>convert_markdown \u2014 Return converted markdown.</p> </li> <li> <p>convert_html \u2014 Convert HTML for source pages.</p> </li> </ul> <p> source enum PageKind(*args, **kwds) </p> <p>Bases : Enum</p> <p>Enum representing different types of pages.</p> <p> Attributes </p> <ul> <li> <p>OBJECT</p> </li> <li> <p>SOURCE</p> </li> <li> <p>DOCUMENTATION</p> </li> </ul> <p> source dataclass Page(src_uri: str, name: str, markdown: str, kind: PageKind) </p> <p>Page class.</p> <p> Methods </p> <ul> <li> <p>create_object \u2014 Create an object page.</p> </li> <li> <p>create_source \u2014 Create a source page.</p> </li> <li> <p>create_documentation \u2014 Create a documentation page.</p> </li> <li> <p>is_object_page \u2014 Check if the page is an object page.</p> </li> <li> <p>is_source_page \u2014 Check if the page is a source page.</p> </li> <li> <p>is_api_page \u2014 Check if the page is an API page.</p> </li> <li> <p>is_documentation_page \u2014 Check if the page is a documentation page.</p> </li> <li> <p>generate_markdown \u2014 Generate markdown for the page.</p> </li> <li> <p>convert_markdown \u2014 Convert markdown for the page.</p> </li> <li> <p>convert_html \u2014 Return converted html.</p> </li> </ul> <p> source classmethod Page.create_object(src_uri: str, name: str) \u2192 Page </p> <p>Create an object page.</p> <p> source classmethod Page.create_source(src_uri: str, name: str) \u2192 Page </p> <p>Create a source page.</p> <p> source classmethod Page.create_documentation(src_uri: str, content: str) \u2192 Page </p> <p>Create a documentation page.</p> <p> source method Page.is_object_page() \u2192 bool </p> <p>Check if the page is an object page.</p> <p> source method Page.is_source_page() \u2192 bool </p> <p>Check if the page is a source page.</p> <p> source method Page.is_api_page() \u2192 bool </p> <p>Check if the page is an API page.</p> <p> source method Page.is_documentation_page() \u2192 bool </p> <p>Check if the page is a documentation page.</p> <p> source method Page.generate_markdown() \u2192 None </p> <p>Generate markdown for the page.</p> <p> source method Page.convert_markdown(markdown: str) \u2192 str </p> <p>Convert markdown for the page.</p> <p> source method Page.convert_html(html: str) \u2192 str </p> <p>Return converted html.</p> <p> source generate_module_markdown(module: str) \u2192 tuple[str, list[str]] </p> <p>Create module page.</p> <p> source generate_object_markdown(name: str, module: str) \u2192 tuple[str, list[str]] </p> <p>Create object page.</p> <p> source convert_markdown(markdown: str, src_uri: str, namespaces: tuple[str, str], predicate: Callable[[Parser, TemplateKind], bool] | None = None) \u2192 str </p> <p>Return converted markdown.</p> <p> source convert_html(html: str, src_uri: str, namespace: str) \u2192 str </p> <p>Convert HTML for source pages.</p>"},{"location":"api/mkapi/parser/","title":"mkapi.parser","text":"mkapi.parser<p> source module mkapi.parser </p> <p>Parsing and managing Python objects for documentation generation.</p> <p>Provide the <code>Parser</code> class, which is responsible for parsing various Python objects such as modules, classes, functions, and attributes. Facilitate the extraction of structured information from these objects to generate comprehensive documentation.</p> <p> Classes </p> <ul> <li> <p>NameSet \u2014 Represent a name set.</p> </li> <li> <p>Parser \u2014 Parse and manage Python objects for documentation generation.</p> </li> <li> <p>Signature \u2014 Represent a function or method signature, consisting of its parts.</p> </li> <li> <p>Part \u2014 Represent a part of the signature.</p> </li> <li> <p>PartKind \u2014 Represent the kind of the signature part.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>get_markdown_link \u2014 Return a Markdown link.</p> </li> <li> <p>get_markdown_name \u2014 Return a Markdown formatted string from the fullname.</p> </li> <li> <p>get_markdown_str \u2014 Return a Markdown formatted string from the type string.</p> </li> <li> <p>get_markdown_expr \u2014 Return a Markdown formatted string from an AST expression.</p> </li> <li> <p>get_markdown_type \u2014 Return a Markdown formatted string from a type or AST expression.</p> </li> <li> <p>get_markdown_text \u2014 Return a Markdown formatted string from the input text.</p> </li> <li> <p>set_markdown_doc \u2014 Set Markdown formatting for the given document.</p> </li> <li> <p>get_signature \u2014 Get the signature of the given object.</p> </li> <li> <p>merge_parameters \u2014 Merge the parameters from the given sections and parameters list.</p> </li> <li> <p>merge_raises \u2014 Merge the raises from the given sections and raises list.</p> </li> <li> <p>merge_returns \u2014 Merge the return type from the given sections and returns expression.</p> </li> <li> <p>merge_attributes \u2014 Merge the attributes from the given sections and attributes list.</p> </li> <li> <p>merge_sections \u2014 Merge sections of documentation for a given object.</p> </li> <li> <p>create_summary_item \u2014 Create a summary item for the given name in the given module.</p> </li> <li> <p>create_classes_from_module \u2014 Create a Classes section from the given module.</p> </li> <li> <p>create_functions_from_module \u2014 Create a Functions section from the given module.</p> </li> <li> <p>create_modules_from_module \u2014 Create a Modules section from the given module.</p> </li> <li> <p>create_modules_from_module_file \u2014 Create a Modules section from the given module.</p> </li> <li> <p>create_methods_from_class \u2014 Create a Methods section from the given class.</p> </li> <li> <p>clean_item_text \u2014 Clean the item text.</p> </li> </ul> <p> source dataclass NameSet(kind: str, name: str, parent: str | None, module: str | None, fullname: str, id: str, obj_id: str, parent_id: str | None, type_params: list[str]) </p> <p>Represent a name set.</p> <p> source dataclass Parser(name: str, module: str | None, obj: Attribute | Class | Function | Module | Property) </p> <p>Parse and manage Python objects for documentation generation.</p> <p>Provide methods to create a parser instance from a given name, retrieve the full name of objects, and parse various components of the documentation, including name sets, signatures, bases, and the first paragraph of the docstring. It also facilitates the merging of documentation sections for a comprehensive output.</p> <p> Attributes </p> <ul> <li> <p>name :  str \u2014 The name of the object to parse.</p> </li> <li> <p>module :  str | None \u2014 The module of the object to parse.</p> </li> <li> <p>obj :  Attribute | Class | Function | Module | Property \u2014 The object to parse.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>create \u2014 Create a <code>Parser</code> instance from a given name.</p> </li> <li> <p>replace_from_module \u2014 Replace the name with the full name from the module.</p> </li> <li> <p>replace_from_object \u2014 Replace the name with the full name from the object.</p> </li> <li> <p>parse_name_set \u2014 Parse the name set.</p> </li> <li> <p>parse_signature \u2014 Parse the signature.</p> </li> <li> <p>parse_bases \u2014 Parse the base classes.</p> </li> <li> <p>parse_summary \u2014 Parse the summary.</p> </li> <li> <p>parse_doc \u2014 Parse the doc.</p> </li> </ul> <p> source classmethod Parser.create(name: str, module: str | None = None) \u2192 Parser | None </p> <p>Create a <code>Parser</code> instance from a given name.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the object to parse.</p> </li> <li> <p>module :  str | None \u2014 The module of the object to parse.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Parser | None \u2014 A <code>Parser</code> instance if the object is valid, otherwise None.</p> </li> </ul> <p> source method Parser.replace_from_module(name: str) \u2192 str | None </p> <p>Replace the name with the full name from the module.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name to replace.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str | None \u2014 The full name if the name is valid, otherwise None.</p> </li> </ul> <p> source method Parser.replace_from_object(name: str) \u2192 str | None </p> <p>Replace the name with the full name from the object.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name to replace.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str | None \u2014 The full name if the name is valid, otherwise None.</p> </li> </ul> <p> source method Parser.parse_name_set() \u2192 NameSet </p> <p>Parse the name set.</p> <p> Returns </p> <ul> <li> <p>NameSet \u2014 The name set.</p> </li> </ul> <p> source method Parser.parse_signature() \u2192 list[tuple[str, str]] </p> <p>Parse the signature.</p> <p> Returns </p> <ul> <li> <p>list[tuple[str, str]] \u2014 The signature.</p> </li> </ul> <p> source method Parser.parse_bases() \u2192 list[str] </p> <p>Parse the base classes.</p> <p> Returns </p> <ul> <li> <p>list[str] \u2014 The base classes.</p> </li> </ul> <p> source method Parser.parse_summary() \u2192 str </p> <p>Parse the summary.</p> <p> Returns </p> <ul> <li> <p>str \u2014 The summary.</p> </li> </ul> <p> source method Parser.parse_doc() \u2192 Doc </p> <p>Parse the doc.</p> <p>The doc is cloned and modified in the following ways:</p> <ul> <li>Merge sections</li> <li>Set markdown</li> <li>Add summary sections from the first paragraph</li> </ul> <p> Returns </p> <ul> <li> <p>Doc \u2014 The doc.</p> </li> </ul> <p> source get_markdown_link(name: str, ref: str | None, *, in_code: bool = False) \u2192 str </p> <p>Return a Markdown link.</p> <p>Generate a Markdown formatted link for a given object name and its reference. It can format the link differently based on whether it is intended to be displayed in code or not.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the object to link.</p> </li> <li> <p>ref :  str | None \u2014 The reference of the object, which is used to create the link target.</p> </li> <li> <p>in_code :  bool \u2014 Whether the link is in code. If True, the link will be formatted for inline code. Defaults to False.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 A Markdown formatted string that represents the link.</p> </li> </ul> <p> Examples </p> <pre><code>get_markdown_link(\"foo\", \"bar\")\n</code></pre> <pre><code>'[foo][__mkapi__.bar]'\n</code></pre> <pre><code>get_markdown_link(\"foo\", \"bar\", in_code=True)\n</code></pre> <pre><code>'[`foo`][__mkapi__.bar]'\n</code></pre> <p> source get_markdown_name(fullname: str, replace: Replace = None) \u2192 str </p> <p>Return a Markdown formatted string from the fullname.</p> <p>Take a fully qualified name (e.g., \"foo.bar\") and generate a Markdown formatted link for each component of the name. It splits the fullname into its constituent parts and creates links for each part using the <code>get_markdown_link</code> function. If a replacement function is provided, it will be applied to each reference before generating the links.</p> <p> Parameters </p> <ul> <li> <p>fullname :  str \u2014 The fully qualified name of the object, formatted as a dot-separated string (e.g., \"foo.bar\").</p> </li> <li> <p>replace :  Replace, optional \u2014 A function that takes a string and returns a modified string. This function is applied to each reference before generating the Markdown links. Defaults to None.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 A Markdown formatted string that represents the links for each     component of the fullname.</p> </li> </ul> <p> Examples </p> <pre><code>get_markdown_name(\"foo.bar\")\n</code></pre> <pre><code>'[foo][__mkapi__.foo].[bar][__mkapi__.foo.bar]'\n</code></pre> <pre><code>get_markdown_name(\"foo.bar\", lambda x: x.replace(\"bar\", \"baz\"))\n</code></pre> <pre><code>'[foo][__mkapi__.foo].[bar][__mkapi__.foo.baz]'\n</code></pre> <p> source get_markdown_str(type_str: str, replace: Replace = None) \u2192 str </p> <p>Return a Markdown formatted string from the type string.</p> <p>Take a type string (e.g., \"foo[bar]\" or \"foo, bar\") and generate a Markdown formatted representation of the string.</p> <p> Parameters </p> <ul> <li> <p>type_str :  str \u2014 The type string to be converted into Markdown format.</p> </li> <li> <p>replace :  Replace, optional \u2014 A function that takes a string and returns a modified string. This function is applied to each reference before generating the Markdown links. Defaults to None.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 A Markdown formatted string that represents the type string with     appropriate links for its components.</p> </li> </ul> <p> Examples </p> <pre><code>get_markdown_str(\"foo[bar]\",None)\n</code></pre> <pre><code>'[foo][__mkapi__.foo][[bar][__mkapi__.bar]]'\n</code></pre> <pre><code>get_markdown_str(\"foo, bar\", lambda x: x.replace(\"bar\", \"baz\"))\n</code></pre> <pre><code>'[foo][__mkapi__.foo], [bar][__mkapi__.baz]'\n</code></pre> <p> source get_markdown_expr(expr: ast.expr | ast.type_param, replace: Replace = None) \u2192 str </p> <p>Return a Markdown formatted string from an AST expression.</p> <p>Take an Abstract Syntax Tree (AST) expression and generate a Markdown formatted representation of the expression. It handles different types of expressions, such as constants and subscripted values.</p> <p> Parameters </p> <ul> <li> <p>expr :  ast.expr | ast.type_param \u2014 The AST expression to be converted into Markdown format.</p> </li> <li> <p>replace :  Replace, optional \u2014 A function that takes a string and returns a modified string. This function is applied to each reference before generating the Markdown links. Defaults to None.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 A Markdown formatted string that represents the AST expression.</p> </li> </ul> <p> Examples </p> <pre><code>import ast\nexpr = ast.parse(\"foo[bar]\").body[0].value\nassert isinstance(expr, ast.Subscript)\nget_markdown_expr(expr)\n</code></pre> <pre><code>'[foo][__mkapi__.foo][[bar][__mkapi__.bar]]'\n</code></pre> <pre><code>get_markdown_expr(expr, lambda x: x.replace(\"bar\", \"baz\"))\n</code></pre> <pre><code>'[foo][__mkapi__.foo][[bar][__mkapi__.baz]]'\n</code></pre> <p> source get_markdown_type(type_: str | ast.expr | None, replace: Replace) \u2192 str </p> <p>Return a Markdown formatted string from a type or AST expression.</p> <p>Take a type, which can be a string, an AST expression, or None, and generate a Markdown formatted representation. If the input is None, it returns an empty string.</p> <p> Parameters </p> <ul> <li> <p>type_ :  str | ast.expr | None \u2014 The type or AST expression to be converted into Markdown format. Can be a string, an AST expression, or None.</p> </li> <li> <p>replace :  Replace \u2014 A function that takes a string and returns a modified string. This function is applied to each reference before generating the Markdown links.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 A Markdown formatted string representing the type or AST expression.     Returns an empty string if the input is None.</p> </li> </ul> <p> source get_markdown_text(text: str, replace: Replace) \u2192 str </p> <p>Return a Markdown formatted string from the input text.</p> <p>Process the input text to convert specific patterns into Markdown formatted links. It uses a regular expression to identify code segments and applies a replacement function if provided.</p> <p> Parameters </p> <ul> <li> <p>text :  str \u2014 The input text to be converted into Markdown format.</p> </li> <li> <p>replace :  Replace \u2014 A function that takes a string and returns a modified string. This function is applied to each identifier before generating the Markdown links.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 A Markdown formatted string with appropriate links for identifiers.</p> </li> </ul> <p> Examples </p> <pre><code>get_markdown_text(\"Use `foo.bar`.\", lambda x: x.replace(\"bar\", \"baz\"))\n</code></pre> <pre><code>'Use [`foo.bar`][__mkapi__.foo.baz].'\n</code></pre> <p> source set_markdown_doc(doc: Doc, replace: Replace) \u2192 None </p> <p>Set Markdown formatting for the given document.</p> <p>Update the text and type of the provided <code>Doc</code> object and its sections and items to be Markdown formatted. It uses the <code>get_markdown_text</code> and <code>get_markdown_type</code> functions to convert the text and type of the document, sections, and items.</p> <p> Parameters </p> <ul> <li> <p>doc :  Doc \u2014 The document object to be updated with Markdown formatting.</p> </li> <li> <p>replace :  Replace \u2014 A function that takes a string and returns a modified string. This function is applied to each identifier before generating the Markdown links.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>None \u2014 This function does not return a value; it modifies the <code>Doc</code> object in place.</p> </li> </ul> <p> source dataclass Signature(parts: list[Part]) </p> <p>Represent a function or method signature, consisting of its parts.</p> <p>Encapsulate the individual components of a signature, allowing for easy access and iteration over the parts. Each part can represent different elements of the signature, such as parameters, return types, and other syntactical elements.</p> <p> Attributes </p> <ul> <li> <p>parts :  list[Part] \u2014 A list of parts of the signature.</p> </li> </ul> <p> source dataclass Part(name: ast.expr | str, _kind: PartKind) </p> <p>Represent a part of the signature.</p> <p> Attributes </p> <ul> <li> <p>name :  ast.expr | str \u2014 The name of the signature part.</p> </li> <li> <p>kind :  str \u2014 The kind of the signature part as a string.</p> </li> </ul> <p> source property Part.kind: str </p> <p>The kind of the signature part as a string.</p> <p> source enum PartKind(*args, **kwds) </p> <p>Bases : Enum</p> <p>Represent the kind of the signature part.</p> <p> Attributes </p> <ul> <li> <p>ANN</p> </li> <li> <p>ARG</p> </li> <li> <p>ARROW</p> </li> <li> <p>COLON</p> </li> <li> <p>COMMA</p> </li> <li> <p>DEFAULT</p> </li> <li> <p>EQUAL</p> </li> <li> <p>PAREN</p> </li> <li> <p>RETURN</p> </li> <li> <p>SLASH</p> </li> <li> <p>STAR</p> </li> </ul> <p> source get_signature(obj: Class | Function | Attribute | Property) \u2192 Signature </p> <p>Get the signature of the given object.</p> <p>Take an object, which can be a Class, Function, Attribute, or Property, and return its signature as a Signature object. The signature includes various parts such as parameters, return types, and other syntactical elements.</p> <p> Parameters </p> <ul> <li> <p>obj :  Class | Function | Attribute | Property \u2014 The object whose signature is to be retrieved.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Signature \u2014 The signature of the given object.</p> </li> </ul> <p> source merge_parameters(sections: list[Section], params: list[Parameter]) \u2192 None </p> <p>Merge the parameters from the given sections and parameters list.</p> <p>Update the Parameters section of the documentation by merging the provided parameters list. If a parameter in the section does not have a type, it will be updated with the type from the parameters list.</p> <p> Parameters </p> <ul> <li> <p>sections :  list[Section] \u2014 The list of documentation sections.</p> </li> <li> <p>params :  list[Parameter] \u2014 The list of parameters to merge.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>None \u2014 None</p> </li> </ul> <p> source merge_raises(sections: list[Section], raises: list[ast.expr]) \u2192 None </p> <p>Merge the raises from the given sections and raises list.</p> <p>Update the Raises section of the documentation by merging the provided raises list. If a raise in the section does not have a type, it will be updated with the type from the raises list.</p> <p> Parameters </p> <ul> <li> <p>sections :  list[Section] \u2014 The list of documentation sections.</p> </li> <li> <p>raises :  list[ast.expr] \u2014 The list of raises to merge.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>None \u2014 None</p> </li> </ul> <p> source merge_returns(sections: list[Section], returns: ast.expr | None, module: str) \u2192 None </p> <p>Merge the return type from the given sections and returns expression.</p> <p>Update the Returns or Yields section of the documentation by merging the provided returns expression. If the section does not exist and the returns expression is provided, a new section will be created. If the section exists but does not have a type, it will be updated with the type from the returns expression.</p> <p> Parameters </p> <ul> <li> <p>sections :  list[Section] \u2014 The list of documentation sections.</p> </li> <li> <p>returns :  ast.expr | None \u2014 The returns expression to merge.</p> </li> <li> <p>module :  str | None \u2014 The module of the object to render.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>None \u2014 None</p> </li> </ul> <p> source merge_attributes(sections: list[Section], attrs: list[Type], ignore_names: list[str] | None = None, *, ignore_empty: bool = True) \u2192 None </p> <p>Merge the attributes from the given sections and attributes list.</p> <p>Update the Attributes section of the documentation by merging the provided attributes list. If the section does not exist and the attributes list is provided, a new section will be created. If the section exists but does not have a type, it will be updated with the type from the attributes list.</p> <p> Parameters </p> <ul> <li> <p>sections :  list[Section] \u2014 The list of documentation sections.</p> </li> <li> <p>attrs :  list[Type] \u2014 The list of attributes to merge.</p> </li> <li> <p>ignore_names :  list[str] | None, optional \u2014 The list of attribute names to ignore. Used for skipping built-in attributes. Defaults to None.</p> </li> <li> <p>ignore_empty :  bool, optional \u2014 Whether to ignore attributes with empty documentation. Defaults to True.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>None \u2014 None</p> </li> </ul> <p> source merge_sections(sections: list[Section], obj: Attribute | Class | Function | Module | Property) \u2192 None </p> <p>Merge sections of documentation for a given object.</p> <p>Take a list of sections and an object, and merge the documentation sections for the object. Handle different types of objects, including modules, classes, functions, and properties, and merge attributes, parameters, raises, and returns sections as appropriate.</p> <p> Parameters </p> <ul> <li> <p>sections :  list[Section] \u2014 The list of sections to merge.</p> </li> <li> <p>obj :  Attribute | Class | Function | Module | Property \u2014 The object whose documentation sections are to be merged.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>None \u2014 None</p> </li> </ul> <p> source create_summary_item(name: str, module: str | None) \u2192 Item | None </p> <p>Create a summary item for the given name in the given module.</p> <p>Take a fully qualified name, create a parser for it, and extract the name set and summary from the parser. Construct an Item with the name, type (None), and summary.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The fully qualified name of the object.</p> </li> <li> <p>module :  str \u2014 The name of the module.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Item | None \u2014 The summary item if created, otherwise None.</p> </li> </ul> <p> source create_classes_from_module(module: str) \u2192 Section | None </p> <p>Create a Classes section from the given module.</p> <p>Take a module name, check if it is a package, and iterate over the classes in the module. For each class, create a summary item and add it to the Classes section.</p> <p> Parameters </p> <ul> <li> <p>module :  str \u2014 The name of the module.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Section | None \u2014 The Classes section if created, otherwise None.</p> </li> </ul> <p> source create_functions_from_module(module: str) \u2192 Section | None </p> <p>Create a Functions section from the given module.</p> <p>Take a module name, and iterate over the functions in the module. For each function, create a summary item and add it to the Functions section.</p> <p> Parameters </p> <ul> <li> <p>module :  str \u2014 The name of the module.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Section | None \u2014 The Functions section if created, otherwise None.</p> </li> </ul> <p> source create_modules_from_module(module: str) \u2192 Section | None </p> <p>Create a Modules section from the given module.</p> <p>Take a module name, check if it is a package, and iterate over the submodules in the module. For each submodule, create a summary item and add it to the Modules section.</p> <p> Parameters </p> <ul> <li> <p>module :  str \u2014 The name of the module.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Section | None \u2014 The Modules section if created, otherwise None.</p> </li> </ul> <p> source create_modules_from_module_file(module: str) \u2192 Section | None </p> <p>Create a Modules section from the given module.</p> <p>Take a module name, check if it is a package, and iterate over the submodules in the module. For each submodule, create a summary item and add it to the Modules section.</p> <p> Parameters </p> <ul> <li> <p>module :  str \u2014 The name of the module.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Section | None \u2014 The Modules section if created, otherwise None.</p> </li> </ul> <p> source create_methods_from_class(name: str, module: str) \u2192 Section | None </p> <p>Create a Methods section from the given class.</p> <p>Take a class name and module name, and iterate over the methods in the class. For each method, create a summary item and add it to the Methods section.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the class.</p> </li> <li> <p>module :  str \u2014 The name of the module.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Section | None \u2014 The Methods section if created, otherwise None.</p> </li> </ul> <p> source clean_item_text(text: str) \u2192 str </p> <p>Clean the item text.</p>"},{"location":"api/mkapi/plugin/","title":"mkapi.plugin","text":"mkapi.plugin<p> source module mkapi.plugin </p> <p> Classes </p> <ul> <li> <p>Plugin</p> </li> </ul> <p> Functions </p> <ul> <li> <p>generate_file \u2014 Generate a <code>File</code> instance for a given source URI and object name.</p> </li> </ul> <p> source class Plugin() </p> <p>Bases : BasePlugin[Config]</p> <p> Attributes </p> <ul> <li> <p>supports_multiple_instances :  bool \u2014 Set to true in subclasses to declare support for adding the same plugin multiple times.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>on_config</p> </li> <li> <p>on_files</p> </li> <li> <p>on_page_markdown</p> </li> <li> <p>on_page_content</p> </li> <li> <p>on_post_build</p> </li> </ul> <p> source method Plugin.on_config(config: MkDocsConfig, **kwargs) \u2192 MkDocsConfig </p> <p> source method Plugin.on_files(files: Files, config: MkDocsConfig, **kwargs) \u2192 Files </p> <p> source method Plugin.on_page_markdown(markdown: str, page: MkDocsPage, config: MkDocsConfig, **kwargs) \u2192 str </p> <p> source method Plugin.on_page_content(html: str, page: MkDocsPage, *args, **kwargs) \u2192 str </p> <p> source method Plugin.on_post_build(*args, **kwargs) \u2192 None </p> <p> source generate_file(config: MkDocsConfig, src_uri: str, name: str, search_exclude: bool = False) \u2192 File </p> <p>Generate a <code>File</code> instance for a given source URI and object name.</p> <p>Create a <code>File</code> instance representing a generated file with the specified source URI and object name. The <code>is_modified</code> method is set to check if the destination file exists and if it is older than the module path. This is used to determine if the file needs to be rebuilt in dirty mode.</p> <p> Parameters </p> <ul> <li> <p>config :  MkDocsConfig \u2014 The MkDocs configuration object.</p> </li> <li> <p>src_uri :  str \u2014 The source URI of the file.</p> </li> <li> <p>name :  str \u2014 The object name corresponding to the <code>src_uri</code>.</p> </li> <li> <p>search_exclude :  bool \u2014 Whether to exclude the file from search.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>File \u2014 A <code>File</code> instance representing the generated file.</p> </li> </ul>"},{"location":"api/mkapi/renderer/","title":"mkapi.renderer","text":"mkapi.renderer<p> source module mkapi.renderer </p> <p>Render documentation for Python objects.</p> <p> Classes </p> <ul> <li> <p>TemplateKind \u2014 Enum representing different types of templates.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>load_templates \u2014 Load Jinja2 templates from the specified directory.</p> </li> <li> <p>render \u2014 Render a template with the given parameters.</p> </li> <li> <p>render_heading \u2014 Render a heading for the specified object.</p> </li> <li> <p>render_object \u2014 Render an object entry using the specified parameters.</p> </li> <li> <p>render_document \u2014 Render a document using the specified parameters.</p> </li> <li> <p>render_source \u2014 Render the source code for the specified object.</p> </li> <li> <p>find_max_backticks \u2014 Find the maximum number of consecutive backticks in the source code.</p> </li> </ul> <p> source load_templates(path: Path | None = None) \u2192 None </p> <p>Load Jinja2 templates from the specified directory.</p> <p>Initialize the <code>templates</code> dictionary with Jinja2 templates loaded from the given directory path. If no path is provided, it defaults to the \"templates\" directory located in the same directory as the mkapi module.</p> <p> Parameters </p> <ul> <li> <p>path :  Path | None \u2014 The directory path from which to load the templates. If None, defaults to the \"templates\" directory in the mkapi module.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>None \u2014 None</p> </li> </ul> <p> source enum TemplateKind(*args, **kwds) </p> <p>Bases : Enum</p> <p>Enum representing different types of templates.</p> <p> Attributes </p> <ul> <li> <p>HEADING</p> </li> <li> <p>HEADER</p> </li> <li> <p>OBJECT</p> </li> <li> <p>DOCUMENT</p> </li> <li> <p>SOURCE</p> </li> </ul> <p> source render(name: str, module: str | None, level: int, namespace: str, predicate: Callable[[Parser, TemplateKind], bool] | None = None) \u2192 str </p> <p>Render a template with the given parameters.</p> <p>Render a template based on the provided name, level, namespace, and an optional predicate function. Process the template using the appropriate rendering functions for headings, objects, documents, and source code, depending on the predicate's evaluation.</p> <p> Parameters </p> <ul> <li> <p>name :  str \u2014 The name of the object to render.</p> </li> <li> <p>module :  str | None \u2014 The module of the object to render.</p> </li> <li> <p>level :  int \u2014 The heading level to use for rendering headings.</p> </li> <li> <p>namespace :  str \u2014 The namespace to use for rendering objects.</p> </li> <li> <p>predicate :  Callable[[Parser, TemplateKind], bool] | None, optional \u2014 A function that takes a <code>Parser</code> instance and a <code>TemplateKind</code> enum value, and returns a boolean indicating whether to render the corresponding template section. Defaults to None.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The rendered markdown string.</p> </li> </ul> <p> source render_heading(name_set: NameSet, level: int) \u2192 str </p> <p>Render a heading for the specified object.</p> <p>Render a heading for the specified object using the provided ID, fullname, and level. Use the \"heading\" template to generate the heading.</p> <p> Parameters </p> <ul> <li> <p>name_set :  NameSet \u2014 The name set containing the object's ID and fullname.</p> </li> <li> <p>level :  int \u2014 The heading level to use for rendering headings.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The rendered heading as a markdown string.</p> </li> </ul> <p> source render_object(name_set: NameSet, level: int, namespace: str, signature: list[tuple[str, str]]) \u2192 str </p> <p>Render an object entry using the specified parameters.</p> <p>Render an object entry using the provided object, name set, namespace, signature, and bases. Use the \"object\" template to generate the object entry.</p> <p> Parameters </p> <ul> <li> <p>name_set :  NameSet \u2014 The name set containing the object's ID and fullname.</p> </li> <li> <p>level :  int \u2014 The heading level to use for rendering headings.</p> </li> <li> <p>namespace :  str \u2014 The namespace to use for rendering objects.</p> </li> <li> <p>signature :  list[tuple[str, str]] \u2014 The signature of the object.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The rendered object entry as a markdown string.</p> </li> </ul> <p> source render_document(doc: Doc, bases: list[str]) \u2192 str </p> <p>Render a document using the specified parameters.</p> <p>Render a document using the provided document. Use the \"document\" template to generate the document.</p> <p> Parameters </p> <ul> <li> <p>doc :  Doc \u2014 The document to render.</p> </li> <li> <p>bases :  list[str] \u2014 The bases of the object.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The rendered document as a markdown string.</p> </li> </ul> <p> source render_source(obj: Object, attr: str = '') \u2192 str </p> <p>Render the source code for the specified object.</p> <p>Render the source code for the specified object using the provided object and attribute name. Use the \"source\" template to generate the source code.</p> <p> Parameters </p> <ul> <li> <p>obj :  Object \u2014 The object to render.</p> </li> <li> <p>attr :  str \u2014 The attribute name to render.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The rendered source code as a markdown string.</p> </li> </ul> <p> source find_max_backticks(source_code: str) \u2192 int </p> <p>Find the maximum number of consecutive backticks in the source code.</p> <p> Parameters </p> <ul> <li> <p>source_code :  str \u2014 The source code to search.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>int \u2014 The maximum number of consecutive backticks.</p> </li> </ul>"},{"location":"api/example/","title":"example","text":"example<p> source package example </p> <p>Example package.</p> <p> Modules </p> <ul> <li> <p>example.sub \u2014 Subpackage.</p> </li> <li> <p>example.mod_a \u2014 Module A.</p> </li> </ul>"},{"location":"api/example/sub/","title":"example.sub","text":"example.sub<p> source package example.sub </p> <p>Subpackage.</p> <p> Classes </p> <ul> <li> <p>ClassA \u2014 Class A.</p> </li> <li> <p>ClassB \u2014 Class B.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>func_a \u2014 Function A.</p> </li> <li> <p>func_b \u2014 Function B.</p> </li> </ul> <p> source class ClassA(a: str) </p> <p>Class A.</p> <p> Parameters </p> <ul> <li> <p>a :  str \u2014 A string.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>attr_a :  str \u2014 Attribute A.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>method_a \u2014 Method A. Return <code>ClassA</code>.</p> </li> </ul> <p> source method ClassA.method_a(x: Iterable[str], y: ClassB) \u2192 ClassA </p> <p>Method A. Return <code>ClassA</code>.</p> <p> Parameters </p> <ul> <li> <p>x :  Iterable[str] \u2014 An iterable of strings.</p> </li> <li> <p>y :  ClassB \u2014 An instance of <code>ClassB</code>.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>ClassA \u2014 An instance of <code>ClassA</code>.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source class ClassB() </p> <p>Class B.</p> <p> Methods </p> <ul> <li> <p>method_b \u2014 Method B.</p> </li> </ul> <p> source method ClassB.method_b() </p> <p>Method B.</p> <p> source func_a(x: int) \u2192 int </p> <p>Function A.</p> <p> Parameters </p> <ul> <li> <p>x :  int \u2014 An integer.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>int \u2014 An integer.</p> </li> </ul> <p>See Also</p> <ul> <li><code>ClassA.method_a</code></li> <li><code>ClassB.method_b</code></li> <li><code>func_b</code></li> </ul> <p> source func_b() </p> <p>Function B.</p>"},{"location":"api/example/sub/mod_b/","title":"example.sub.mod_b","text":"example.sub.mod_b<p> source module example.sub.mod_b </p> <p>Module B.</p> <p> Classes </p> <ul> <li> <p>ClassB \u2014 Class B.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>func_b \u2014 Function B.</p> </li> </ul> <p> source class ClassB() </p> <p>Class B.</p> <p> Methods </p> <ul> <li> <p>method_b \u2014 Method B.</p> </li> </ul> <p> source method ClassB.method_b() </p> <p>Method B.</p> <p> source func_b() </p> <p>Function B.</p>"},{"location":"api/example/mod_a/","title":"example.mod_a","text":"example.mod_a<p> source module example.mod_a </p> <p>Module A.</p> <p> Classes </p> <ul> <li> <p>ClassA \u2014 Class A.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>func_a \u2014 Function A.</p> </li> <li> <p>sum_and_product \u2014 Computes the sum and product of two integers</p> </li> </ul> <p> source class ClassA(a: str) </p> <p>Class A.</p> <p> Parameters </p> <ul> <li> <p>a :  str \u2014 A string.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>attr_a :  str \u2014 Attribute A.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>method_a \u2014 Method A. Return <code>ClassA</code>.</p> </li> </ul> <p> source method ClassA.method_a(x: Iterable[str], y: ClassB) \u2192 ClassA </p> <p>Method A. Return <code>ClassA</code>.</p> <p> Parameters </p> <ul> <li> <p>x :  Iterable[str] \u2014 An iterable of strings.</p> </li> <li> <p>y :  ClassB \u2014 An instance of <code>ClassB</code>.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>ClassA \u2014 An instance of <code>ClassA</code>.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source func_a(x: int) \u2192 int </p> <p>Function A.</p> <p> Parameters </p> <ul> <li> <p>x :  int \u2014 An integer.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>int \u2014 An integer.</p> </li> </ul> <p>See Also</p> <ul> <li><code>ClassA.method_a</code></li> <li><code>ClassB.method_b</code></li> <li><code>func_b</code></li> </ul> <p> source sum_and_product(x, y) </p> <p>Computes the sum and product of two integers</p> <p> Parameters </p> <ul> <li> <p>x :  int</p> </li> <li> <p>y :  int</p> </li> </ul> <p> Returns </p> <ul> <li> <p>s :  int \u2014 sum of x and y</p> </li> <li> <p>p :  int \u2014 product of x and y</p> </li> </ul>"}]}